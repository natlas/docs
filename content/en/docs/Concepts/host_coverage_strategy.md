---
title: "Host Coverage Strategy"
linkTitle: "Host Coverage Strategy"
weight: 4
description: >
  How does Natlas determine what to scan next?
---

The Natlas platform is a system capable of running either for long-term inventory scans with historical records or as a system intended for use as a search-head during an assessment. Natlas is intended for scanning any range scope - from a small local network up to the entire internet.

Therefore scanning in Natlas has some operational requirements:

- It can not stress network bottlenecks
  - This can happen if scans for different targets share networking routes within short durations (e.g. anycast)
  - Stability is critical for getting reliable and trustworthy results
  - Avoids needlessly triggering alarms
- It must avoid interrogation by monitoring strategies
  - Being detected by monitoring is typically Not-A-Big-Deal (TM), however nice to avoid
  - It's more important to have the scan targets be difficult to correlate
    - Difficult to infer scope and objectives of the campaign
    - Difficult to relate scans to later stages
- Low resource cost on behalf of the scanner (e.g. CPU, memory)

For tools that are either long-running or are critical applications, other features may be desirable, for example:

- Provide a guarantee that coverage has been achieved
- Resumable/interruptible scans, or scans that can be migrated
- Scope that can be updated during runtime to meet pacing needs of the operating group

Because Natlas is used to provide comprehensive views of network inventory, guaranteeing coverage after a given amount of time is a high priority. It's also useful to Natlas for scans to have a level of determinism - so that scans (including those deployed for large scopes) can be continued if the systems involved crash or are otherwise interrupted.

## Strategy

To do this, the scanning engine performs randomized scans. Randomized scans avoid visiting clusters of similar target addresses (which could be anycast to the same systems, or otherwise rely on similar intermediary nodes and networking paths). This makes bursts of activity in any particular network route statistically unlikely by spreading out target traffic across the entire scope.

Calling into an operating system provided source of randomness is a typical way to solve this problem. However, uniformly sampling scope ranges without storing state about previous scans and compensating for them makes it statistically improbable that **N** randomly chosen network scans targeting **N** addresses will result in full coverage. In fact, after one round of **N** random samples only slightly more than half of endpoints are expected to have been scanned, and the scanner will have to scan about **12x-24x** as many to expect to get full coverage (even then there are no guarantees, and the situation is worse for the larger ranges concerned in IPv6).

Storing some kind of state to target new scans toward unreached endpoints seems inevitable. Unfortunately, storing full tables of scan state information for all endpoints is a formidable memory management problem for scans that grow larger than hundreds of thousands of endpoints (especially for full internet scans, or scans over IPv6 space). Traditional data-structures like bloom filters, cuckoo filters, and MRE caches have disadvantages that they speed up scan coverage without providing full coverage guarantees at the addititional cost of introducing false positives.

Natlas uses a mathematical structure called a cyclic group to provide well distributed random numbers that also provably fully cover **N** targets with **N** sample scans. While generic versions of the algorithms involved with computing cyclic groups are complex and large sizes are used in modern cryptography, Natlas uses small cyclic groups whose computation is well within reasonable expected runtimes.

## Mathematical Background

There's a large amount of background and terminology that this article will not go into (sorry number theorists!) out of respect for time.

> For number theorists - in short: Natlas uses a multiplicative cyclic group of prime order, and computes the factorization of the order of the group to obtain possible subgroup orders. Natlas uses these subgroup orders for generator testing, and finds random generators. Natlas uses these generators to determine the order of the scan. Mapping between group elements and IP addresses is performed by creating an index over IP addresses using canonical IP ordering.

Wikipedia describes Cyclic Groups as "In algebra, a cyclic group or monogenous group is a group that is generated by a single element." This description is abstract but alludes the mathematical fact that we exploit for scanning in Natlas: an entire "group" (of IP addresses) can be generated by a small amount of state/information, and we're guaranteed to generate every IP address in some order (we'll later show how that order is pseudorandom).

Let's try out generating the "group of numbers 1-6" using the "single element 3". We will multiply 3 by itself over and over, and take the remainder **mod 7** (to keep the values between 1 and 6).

3 mod 7 = **3**

3x3 mod 7 = **2**

3x3x3 mod 7 = **6**

3x3x3x3 mod 7 = **4**

3x3x3x3x3 mod 7 = **5**

3x3x3x3x3x3 mod 7 = **1**

By using "3" as a generator, we were able to obtain all numbers 1-6 in a random-looking order. It's important that "mod 7" is using a prime number, or else this won't work.

> Mathematicians have proven that every cyclic group that isn't infinite in size, if the items in the "group" are relabeled, is equivalent to the numbers **mod n** where **n** is a prime number or a prime number raised to a power.

What Natlas will do is determine the total size of a scan scope, say 12345678 total IP addresses, and find the next prime number 12345701. Using calculations "mod 12345701", we find a generator (the number 3 in the above example) and use it to list every number from 1-12345700 in a random-looking order. Natlas needs to throw away every number between 12345678 and 12345700, but there aren't that many of them.

There are important implementation details.

### Finding a Generator

Not every number is a generator for a cyclic group. Take for example the proposed generator 2 with the group 1-6 from above:

2 mod 7 = **2**

2x2 mod 7 = **4**

2x2x2 mod 7 = **1**

The next number generated (2x2x2x2 mod 7 = 2) is one that we've already visited. The reason for this is that 2 is a generator for a subgroup, and not the whole group. You may notice that the subgroup generated is exactly half as long as the whole group. That's a good observation, and its true that all subgroups have a length that evenly divides the total size of the whole group.

Natlas needs to find a true generator. To do this, it takes the prime number for the group, and subtracts one to get the number of values in (or "order of") the group. As an example, "mod 7" has 6 elements. Then, the scanning engine factors this number to obtain all possible subgroup lengths. It randomly generates possible generators and tests them to see if they generate any subgroups. If a number is not a generator for any subgroup, it generates the whole group!

The number of generators for a given group can be counted using a complex formula (involving the number of relatively prime numbers to other numbers). Needless to say, there are always a "lot" of generators, and this method of generation will quickly find one.

Our scanning engine chooses a random generator every restart, and picks a random location in that generator's cycle to start scanning from. This increases the uniform pseudorandom nature of the scanning strategy.

### Computing Modular Exponentiation Quickly

The scanning engine uses an algorithm capable of quickly calculating exponents, and keeps the numbers small by keeping all intermediate values modulo the group order.

Essentially, 3x3x3x3x3 mod 7 doesn't need to be explicitly calculated from scratch if 3x3x3x3 mod 7 already has. Just multiply the second number by the 3 to obtain the first.

Calculating arbitrarily large exponents of arbitrary generators can be done by repeatedly squaring an intermediate value, and multiplying that value into a final calculation if it contributes.

Wikipedia hosts a well-written article on the details of [Exponentiation by squaring]

### Indexing IP Addresses

When all of the elements of the group can be generated, we need to be able to translate them back into IP addresses. To do this, we put IP network blocks into a random access array in canonical address order (e.g. 1.1.1.1 < 192.168.0.1). One time at the start of any scan configuration, the scanning engine walks the address blocks and counts the total number of IP addresses accumulated up until each networking block.

With an index, binary search can then be used to determine which network address range is associated, and within that range, which IP address is mapped. It's important to note that changing the scope of a scan causes all of the addresses to be reindexed.

### But Factoring and Discrete Log Are Hard

Yes and No!

Natlas's generator has some properties which make it similar to provably secure pseudorandom number generators (e.g. Blum Blum Shub), but the numbers involved - 32 bits for IPv4 128 bits for IPv6 - are small enough that these calculations can be done rather simply. Performance has been tested on the full 32 bit range and into the 64 bit ranges without any obvious performance issues.

### The Average Time Delta is Too Variable

If you're trying to get consistent scan cycles, it may be valuable to not generate a new random order for every cycle. The random order tends to mean that sometimes a host is scanned a couple minutes apart and other times a couple days apart, which isn't necessarily ideal. To this end, Natlas introduced a `CONSISTENT_SCAN_CYCLE` option that can be set, which will reuse the same random order as long as the scope hasn't changed, resulting in more consistent timing between scans of a given host.

## Show me the code

The [cyclic PRNG] has been separated out from the Natlas platform to a standalone package that can be installed via pip. You can checkout the code yourself or jump right in by running `pipenv install cyclicprng`.

Initialization of the PRNG is quick, even for address spaces up to 2^128 (the entire IPv6 address space) - typically less than a tenth of a second on a modern computer.

The process by which these cyclical random numbers are turned into an IP address to scan has not been separated from the Natlas server at this time, however the logic is pretty well consolidated into [the scan manager].

[Exponentiation by squaring]: https://en.wikipedia.org/wiki/Exponentiation_by_squaring
[cyclic PRNG]: https://github.com/natlas/cyclicprng
[the scan manager]: https://github.com/natlas/natlas/blob/main/natlas-server/app/scope/scan_manager.py
